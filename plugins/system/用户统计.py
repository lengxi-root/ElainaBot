from core.plugin.PluginManager import Plugin
from function.db_pool import DatabaseService
import json
import logging
import time
import datetime
from config import LOG_DB_CONFIG, USE_MARKDOWN, OWNER_IDS
import traceback
from function.httpx_pool import sync_get, get_json
from function.database import Database

import os
import sys
import subprocess
import platform
import re

from function.log_db import LogDatabasePool
from core.plugin.PluginManager import PluginManager

logger = logging.getLogger('user_stats')

BOT_API_URL = "https://i.elaina.vin/api/bot/xx.php?bot={}&type=0"
BOT_DATA_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "data", "cxbot")
CONFIRMED_USERS_FILE = os.path.join(BOT_DATA_DIR, "Êü•ËØ¢Êú∫Âô®‰∫∫_Á°ÆËÆ§Áî®Êà∑.json")
QUERY_RECORDS_FILE = os.path.join(BOT_DATA_DIR, "Êü•ËØ¢Êú∫Âô®‰∫∫_ËÆ∞ÂΩï.json")
BLACKLIST_FILE = os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))), "data", "blacklist.json")

os.makedirs(BOT_DATA_DIR, exist_ok=True)

confirmed_users = set()
query_records = {}
blacklist = {}

def load_bot_query_data():
    global confirmed_users, query_records
    
    if os.path.exists(CONFIRMED_USERS_FILE):
        with open(CONFIRMED_USERS_FILE, 'r', encoding='utf-8') as f:
            confirmed_users = set(json.load(f))
    
    if os.path.exists(QUERY_RECORDS_FILE):
        with open(QUERY_RECORDS_FILE, 'r', encoding='utf-8') as f:
            query_records = json.load(f)

def save_confirmed_users():
    with open(CONFIRMED_USERS_FILE, 'w', encoding='utf-8') as f:
        json.dump(list(confirmed_users), f)

def save_query_records():
    with open(QUERY_RECORDS_FILE, 'w', encoding='utf-8') as f:
        json.dump(query_records, f)

def record_query(user_id, qq_number):
    user_id = str(user_id)
    if user_id not in query_records:
        query_records[user_id] = []
    if qq_number not in query_records[user_id]:
        query_records[user_id].append(qq_number)
        save_query_records()

def load_blacklist():
    global blacklist
    if not os.path.exists(BLACKLIST_FILE):
        blacklist = {}
        return
    with open(BLACKLIST_FILE, 'r', encoding='utf-8') as f:
        blacklist = json.load(f)

def save_blacklist():
    with open(BLACKLIST_FILE, 'w', encoding='utf-8') as f:
        json.dump(blacklist, f, ensure_ascii=False, indent=2)

load_bot_query_data()
load_blacklist()

class system_plugin(Plugin):
    priority = 10
    _restart_status_checked = False
    
    @classmethod
    def _get_restart_status_file(cls):
        plugin_dir = os.path.dirname(os.path.abspath(__file__))
        data_dir = os.path.join(plugin_dir, 'data')
        if not os.path.exists(data_dir):
            os.makedirs(data_dir)
        return os.path.join(data_dir, 'restart_status.json')
    
    @classmethod
    def _check_restart_status(cls):
        restart_status_file = cls._get_restart_status_file()
        if not os.path.exists(restart_status_file):
            return
        
        with open(restart_status_file, 'r', encoding='utf-8') as f:
            restart_data = json.load(f)
        
        if restart_data.get('completed', True):
            return
            
        restart_time = restart_data.get('restart_time')
        message_id = restart_data.get('message_id')
        if not (restart_time and message_id):
            return
            
        start_time = datetime.datetime.fromisoformat(restart_time)
        duration_ms = int((datetime.datetime.now() - start_time).total_seconds() * 1000)
        
        cls._send_restart_complete_message(restart_data.get('user_id'), restart_data.get('group_id'), message_id, duration_ms)
        
        restart_data.update({'completed': True})
        with open(restart_status_file, 'w', encoding='utf-8') as f:
            json.dump(restart_data, f, ensure_ascii=False)
    
    @classmethod
    def _send_restart_complete_message(cls, user_id, group_id, message_id, duration_ms):
        from function.Access import BOTAPI, Json
        import random
        
        payload = {
            "msg_type": 0,
            "msg_seq": random.randint(10000, 999999),
            "content": f'‚úÖ ÈáçÂêØÂÆåÊàêÔºÅ\nüïí ËÄóÊó∂: {duration_ms}ms',
            "msg_id": message_id
        }
        
        endpoint = f"/v2/groups/{group_id}/messages" if group_id != 'c2c' else f"/v2/users/{user_id}/messages"
        BOTAPI(endpoint, "POST", Json(payload))
    
    @staticmethod
    def mask_id(id_str, mask_char="*"):
        if not id_str or len(id_str) <= 6:
            return id_str
        if len(id_str) <= 3:
            return id_str
        return id_str[:3] + mask_char * 4 + id_str[-3:]
    
    @staticmethod
    def create_buttons(event, button_configs):
        rows = []
        for row_config in button_configs:
            row = []
            for btn_config in row_config:
                button = {
                    'text': btn_config.get('text', ''),
                    'data': btn_config.get('data', ''),
                    'type': btn_config.get('type', 1),
                    'style': btn_config.get('style', 1),
                    'enter': btn_config.get('enter', True)
                }
                row.append(button)
            rows.append(event.rows(row))
        return event.button(rows)
    
    @staticmethod
    def safe_reply(event, message, buttons=None):
        if USE_MARKDOWN and buttons:
            event.reply(message, buttons, hide_avatar_and_center=True)
        else:
            event.reply(message)
    
    @classmethod
    def get_regex_handlers(cls):
        if not cls._restart_status_checked:
            cls._restart_status_checked = True
            cls._check_restart_status()
        
        return {
            r'^Áî®Êà∑ÁªüËÆ°$': {'handler': 'get_stats', 'owner_only': True},
            r'^ÊàëÁöÑid$': {'handler': 'getid', 'owner_only': False},
            r'^dau(?:\s+)?(\d{4})?$': {'handler': 'handle_dau', 'owner_only': True},
            r'^ÂÖ≥‰∫é$': {'handler': 'about_info', 'owner_only': False},
            r'^dm(.+)$': {'handler': 'send_dm', 'owner_only': True},
            r'^ÈáçÂêØ$': {'handler': 'restart_bot', 'owner_only': True},
            r'^Ë°•ÂÖ®ÊòµÁß∞$': {'handler': 'fill_user_names', 'owner_only': True},
            r'^Êü•ËØ¢Êú∫Âô®‰∫∫\s*\d{1,}$': {'handler': 'handle_bot_query', 'owner_only': False},
            r"^ÊàëÁ°ÆËÆ§Êåá‰ª§'Êü•ËØ¢Êú∫Âô®‰∫∫'ÂäüËÉΩ ‰ªÖÊü•ËØ¢Ëá™Â∑±ÁöÑÊú∫Âô®‰∫∫ÔºåÂ¶ÇÊúâËøùÂèçÔºåÂêéÊûúÁî±Ëá™Â∑±ÊâøÊãÖ„ÄÇ$": {'handler': 'handle_bot_confirm', 'owner_only': False},
            r'ÈªëÂêçÂçïÊ∑ªÂä† *(.+?) *([a-zA-Z0-9]+)': {'handler': 'add_blacklist', 'owner_only': True},
            r'ÈªëÂêçÂçïÂà†Èô§ *([a-zA-Z0-9]+)': {'handler': 'remove_blacklist', 'owner_only': True},
            r'ÈªëÂêçÂçïÊü•Áúã': {'handler': 'view_blacklist', 'owner_only': True},
            r'ÈªëÂêçÂçïÂ∏ÆÂä©': {'handler': 'show_blacklist_help', 'owner_only': True}
        }
    
    @staticmethod
    def getid(event):
        info_parts = [
            f"<@{event.user_id}>",
            f"Áî®Êà∑ID: {event.user_id}",
            f"Áæ§ÁªÑID: {event.group_id}"
        ]
        
        system_plugin.safe_reply(event, "\n".join(info_parts))
    
    @staticmethod
    def send_dm(event):
        content = event.matches[0] if event.matches and event.matches[0] else ""
        if not content.strip():
            event.reply(f"‚ùå Ê∂àÊÅØÂÜÖÂÆπ‰∏çËÉΩ‰∏∫Á©∫\nüí° ‰ΩøÁî®Ê†ºÂºèÔºödm+Ê∂àÊÅØÂÜÖÂÆπ")
            return
        
        if '\\n' in content:
            content = content.replace('\\n', '\n')
        if '\\t' in content:
            content = content.replace('\\t', '\t')
        if '\\r' in content:
            content = content.replace('\\r', '\r')
        if '\\\\' in content:
            content = content.replace('\\\\', '\\')
        
        if USE_MARKDOWN:
            button_configs = [[
                {'text': 'ÂÜçÊ¨°ÈáçËØï', 'data': event.content, 'enter': False, 'style': 1, 'type': 2},
                {'text': 'ÈáçÊñ∞ÊµãËØï', 'data': 'dm', 'enter': False, 'style': 1, 'type': 2}
            ]]
            buttons = system_plugin.create_buttons(event, button_configs)
            event.reply(content, buttons)
        else:
            event.reply(content)
    
    @staticmethod
    def _get_user_qq(user_id):
        result = DatabaseService.execute_query("SELECT qq FROM M_users WHERE user_id = %s", (user_id,))
        return result.get('qq') if result else None
    
    @staticmethod
    def _get_user_permission(user_id):
        resp = sync_get('https://api.elaina.vin/api/ÁßØÂàÜ/ÁâπÊÆäÁî®Êà∑.php', timeout=5)
        data = resp.json()
        user_id_str = str(user_id)
        
        for item in data:
            if item.get('openid') == user_id_str or item.get('qq') == user_id_str:
                return item.get('reason', 'ÁâπÊÆäÊùÉÈôêÁî®Êà∑')
        return "ÊôÆÈÄöÁî®Êà∑"
    
    @classmethod
    def handle_dau(cls, event):
        date_str = event.matches[0] if event.matches and event.matches[0] else None
        
        if date_str:
            cls._handle_specific_date_dau(event, date_str)
        else:
            cls._handle_today_dau(event)
    
    @classmethod
    def _handle_specific_date_dau(cls, event, date_str):
        if len(date_str) != 4:
            event.reply("Êó•ÊúüÊ†ºÂºèÈîôËØØÔºåËØ∑‰ΩøÁî®MMDDÊ†ºÂºèÔºå‰æãÂ¶ÇÔºödau0522Ë°®Á§∫5Êúà22Êó•")
            return
            
        current_year = datetime.datetime.now().year
        month = int(date_str[:2])
        day = int(date_str[2:])
        query_date = datetime.datetime(current_year, month, day)
        
        if query_date > datetime.datetime.now():
            query_date = datetime.datetime(current_year - 1, month, day)
            
        formatted_date = query_date.strftime('%Y%m%d')
        cls._get_dau_data(event, formatted_date)
    
    @classmethod
    def _handle_today_dau(cls, event):
        today = datetime.datetime.now()
        today_str = today.strftime('%Y%m%d')
        yesterday = today - datetime.timedelta(days=1)
        yesterday_str = yesterday.strftime('%Y%m%d')
        current_hour = today.hour
        current_minute = today.minute
        cls._get_dau_data(event, today_str, yesterday_str, current_hour, current_minute)
    
    @classmethod
    def _get_dau_data(cls, event, date_str, yesterday_str=None, current_hour=None, current_minute=None):
        start_time = time.time()
        target_date = datetime.datetime.strptime(date_str, '%Y%m%d')
        today = datetime.datetime.now().date()
        is_today = target_date.date() == today
        
        if not is_today:
            from function.dau_analytics import get_dau_analytics
            dau_analytics = get_dau_analytics()
            dau_data = dau_analytics.load_dau_data(target_date)
            
            if dau_data:
                cls._send_dau_from_database(event, dau_data, target_date, start_time)
                return
            
            display_date = f"{date_str[4:6]}-{date_str[6:8]}"
            event.reply(f"<@{event.user_id}>\n‚ùå {display_date} ÁöÑDAUÊï∞ÊçÆÊú™ÁîüÊàêÊàñÊó†ËØ•Êó•ÊúüÊï∞ÊçÆ")
            return
        
        if not LOG_DB_CONFIG.get('enabled', False):
            event.reply("Êó•ÂøóÊï∞ÊçÆÂ∫ìÊú™ÂêØÁî®ÔºåÊó†Ê≥ïËé∑ÂèñDAUÁªüËÆ°")
            return
            
        log_db_pool = LogDatabasePool()
        connection = log_db_pool.get_connection()
        
        if not connection:
            event.reply("Êó†Ê≥ïËøûÊé•Âà∞Êó•ÂøóÊï∞ÊçÆÂ∫ìÔºåËØ∑Á®çÂêéÂÜçËØï")
            return
        
        cursor = connection.cursor()
        table_name = f"Mlog_{date_str}_message"
        
        check_query = """
            SELECT COUNT(*) as count 
            FROM information_schema.tables 
            WHERE table_schema = DATABASE() 
            AND table_name = %s
        """
        
        cursor.execute(check_query, (table_name,))
        result = cursor.fetchone()
        if not result or result['count'] == 0:
            display_date = f"{date_str[4:6]}-{date_str[6:8]}"
            event.reply(f"ËØ•Êó•Êúü({display_date})Êó†Ê∂àÊÅØËÆ∞ÂΩï")
            return
        
        time_condition = ""
        if current_hour is not None and current_minute is not None:
            time_limit = f"{current_hour:02d}:{current_minute:02d}:00"
            time_condition = f" WHERE TIME(timestamp) <= '{time_limit}'"
        
        total_messages_query = f"SELECT COUNT(*) as count FROM {table_name}{time_condition}"
        cursor.execute(total_messages_query)
        total_messages_result = cursor.fetchone()
        total_messages = total_messages_result['count'] if total_messages_result else 0
        
        unique_users_query = f"SELECT COUNT(DISTINCT user_id) as count FROM {table_name}{time_condition}"
        unique_users_query += " AND user_id IS NOT NULL AND user_id != ''" if time_condition else " WHERE user_id IS NOT NULL AND user_id != ''"
        cursor.execute(unique_users_query)
        unique_users_result = cursor.fetchone()
        unique_users = unique_users_result['count'] if unique_users_result else 0
        
        unique_groups_query = f"SELECT COUNT(DISTINCT group_id) as count FROM {table_name}{time_condition}"
        unique_groups_query += " AND group_id != 'c2c' AND group_id IS NOT NULL AND group_id != ''" if time_condition else " WHERE group_id != 'c2c' AND group_id IS NOT NULL AND group_id != ''"
        cursor.execute(unique_groups_query)
        unique_groups_result = cursor.fetchone()
        unique_groups = unique_groups_result['count'] if unique_groups_result else 0
        
        private_messages_query = f"SELECT COUNT(*) as count FROM {table_name}{time_condition}"
        private_messages_query += " AND group_id = 'c2c'" if time_condition else " WHERE group_id = 'c2c'"
        cursor.execute(private_messages_query)
        private_messages_result = cursor.fetchone()
        private_messages = private_messages_result['count'] if private_messages_result else 0
        
        active_groups_query = f"""
            SELECT group_id, COUNT(*) as msg_count 
            FROM {table_name}{time_condition}
            """
        active_groups_query += " AND group_id != 'c2c' AND group_id IS NOT NULL AND group_id != ''" if time_condition else " WHERE group_id != 'c2c' AND group_id IS NOT NULL AND group_id != ''"
        active_groups_query += """
            GROUP BY group_id 
            ORDER BY msg_count DESC 
            LIMIT 2
        """
        cursor.execute(active_groups_query)
        active_groups_result = cursor.fetchall()
        
        active_users_query = f"""
            SELECT user_id, COUNT(*) as msg_count 
            FROM {table_name}{time_condition}
            """
        active_users_query += " AND user_id IS NOT NULL AND user_id != ''" if time_condition else " WHERE user_id IS NOT NULL AND user_id != ''"
        active_users_query += """
            GROUP BY user_id 
            ORDER BY msg_count DESC 
            LIMIT 2
        """
        cursor.execute(active_users_query)
        active_users_result = cursor.fetchall()
        
        hourly_stats_query = f"""
            SELECT HOUR(timestamp) as hour, COUNT(*) as count 
            FROM {table_name}{time_condition} 
            GROUP BY HOUR(timestamp) 
            ORDER BY hour
        """
        cursor.execute(hourly_stats_query)
        hourly_stats_result = cursor.fetchall()
        
        hours_data = {i: 0 for i in range(24)}
        if hourly_stats_result:
            for row in hourly_stats_result:
                hour = row['hour']
                count = row['count']
                hours_data[hour] = count
        
        most_active_hour = max(hours_data.items(), key=lambda x: x[1]) if hours_data else (0, 0)
        
        event_stats = {'group_join_count': 0, 'group_leave_count': 0, 'friend_add_count': 0, 'friend_remove_count': 0}
        if is_today:
            dau_table_name = "Mlog_dau"
            cursor.execute(f"""
                SELECT COUNT(*) as count 
                FROM information_schema.tables 
                WHERE table_schema = DATABASE() 
                AND table_name = %s
            """, (dau_table_name,))
            dau_table_exists = cursor.fetchone()
            
            if dau_table_exists and dau_table_exists['count'] > 0:
                cursor.execute(f"""
                    SELECT group_join_count, group_leave_count, friend_add_count, friend_remove_count
                    FROM {dau_table_name}
                    WHERE date = %s
                """, (target_date.strftime('%Y-%m-%d'),))
                dau_result = cursor.fetchone()
                
                if dau_result:
                    event_stats['group_join_count'] = dau_result.get('group_join_count', 0)
                    event_stats['group_leave_count'] = dau_result.get('group_leave_count', 0)
                    event_stats['friend_add_count'] = dau_result.get('friend_add_count', 0)
                    event_stats['friend_remove_count'] = dau_result.get('friend_remove_count', 0)
        
        display_date = f"{date_str[4:6]}-{date_str[6:8]}"
        
        yesterday_data = None
        if yesterday_str and current_hour is not None and current_minute is not None:
            yesterday_table = f"Mlog_{yesterday_str}_message"
            cursor.execute(check_query, (yesterday_table,))
            y_result = cursor.fetchone()
            
            if y_result and y_result['count'] > 0:
                time_limit = f"{current_hour:02d}:{current_minute:02d}:00"
                y_time_condition = f" WHERE TIME(timestamp) <= '{time_limit}'"
                yesterday_data = {}
                
                cursor.execute(f"SELECT COUNT(*) as count FROM {yesterday_table}{y_time_condition}")
                y_total = cursor.fetchone()
                yesterday_data['total_messages'] = y_total['count'] if y_total else 0
                
                y_users_query = f"SELECT COUNT(DISTINCT user_id) as count FROM {yesterday_table}{y_time_condition}"
                y_users_query += " AND user_id IS NOT NULL AND user_id != ''"
                cursor.execute(y_users_query)
                y_users = cursor.fetchone()
                yesterday_data['unique_users'] = y_users['count'] if y_users else 0
                
                y_groups_query = f"SELECT COUNT(DISTINCT group_id) as count FROM {yesterday_table}{y_time_condition}"
                y_groups_query += " AND group_id != 'c2c' AND group_id IS NOT NULL AND group_id != ''"
                cursor.execute(y_groups_query)
                y_groups = cursor.fetchone()
                yesterday_data['unique_groups'] = y_groups['count'] if y_groups else 0
                
                y_private_query = f"SELECT COUNT(*) as count FROM {yesterday_table}{y_time_condition}"
                y_private_query += " AND group_id = 'c2c'"
                cursor.execute(y_private_query)
                y_private = cursor.fetchone()
                yesterday_data['private_messages'] = y_private['count'] if y_private else 0
        
        info = [
            f'<@{event.user_id}>',
            f'üìä {display_date} Ê¥ªË∑ÉÁªüËÆ°' + (f' (Êà™Ëá≥{current_hour:02d}:{current_minute:02d})' if current_hour is not None else '')
        ]
        
        if yesterday_data:
            y_display_date = f"{yesterday_str[4:6]}-{yesterday_str[6:8]}"
            user_diff = unique_users - yesterday_data['unique_users']
            user_change = f"üî∫{user_diff}" if user_diff > 0 else f"üîª{abs(user_diff)}" if user_diff < 0 else "‚ûñ0"
            info.append(f'üë§ Ê¥ªË∑ÉÁî®Êà∑Êï∞: {unique_users} ({user_change})')
            
            group_diff = unique_groups - yesterday_data['unique_groups']
            group_change = f"üî∫{group_diff}" if group_diff > 0 else f"üîª{abs(group_diff)}" if group_diff < 0 else "‚ûñ0"
            info.append(f'üë• Ê¥ªË∑ÉÁæ§ËÅäÊï∞: {unique_groups} ({group_change})')
            
            msg_diff = total_messages - yesterday_data['total_messages']
            msg_change = f"üî∫{msg_diff}" if msg_diff > 0 else f"üîª{abs(msg_diff)}" if msg_diff < 0 else "‚ûñ0"
            info.append(f'üí¨ Ê∂àÊÅØÊÄªÊï∞: {total_messages} ({msg_change})')
            
            private_diff = private_messages - yesterday_data['private_messages']
            private_change = f"üî∫{private_diff}" if private_diff > 0 else f"üîª{abs(private_diff)}" if private_diff < 0 else "‚ûñ0"
            info.append(f'üì± ÁßÅËÅäÊ∂àÊÅØ: {private_messages} ({private_change})')
        else:
            info.append(f'üë§ Ê¥ªË∑ÉÁî®Êà∑Êï∞: {unique_users}')
            info.append(f'üë• Ê¥ªË∑ÉÁæ§ËÅäÊï∞: {unique_groups}')
            info.append(f'üí¨ Ê∂àÊÅØÊÄªÊï∞: {total_messages}')
            info.append(f'üì± ÁßÅËÅäÊ∂àÊÅØ: {private_messages}')
        
        info.append(f'‚è∞ ÊúÄÊ¥ªË∑ÉÊó∂ÊÆµ: {most_active_hour[0]}ÁÇπ ({most_active_hour[1]})')
        
        if is_today and event_stats and any(event_stats.values()):
            info.append(f'üìà ‰ªäÊó•‰∫ã‰ª∂ÁªüËÆ°:')
            group_join = event_stats["group_join_count"]
            group_leave = event_stats["group_leave_count"]
            friend_add = event_stats["friend_add_count"] 
            friend_remove = event_stats["friend_remove_count"]
            info.append(f'üë• Áæ§üî∫: {group_join} | üîª: {group_leave}')
            info.append(f'üë§ Âèãüî∫: {friend_add} | üîª: {friend_remove}')
            group_net = group_join - group_leave
            friend_net = friend_add - friend_remove
            info.append(f'üìä Áæ§ÂáÄÂ¢û: {group_net:+d} | ÂèãÂáÄÂ¢û: {friend_net:+d}')
        
        if active_groups_result:
            info.append('üîù ÊúÄÊ¥ªË∑ÉÁæ§ÁªÑ:')
            idx = 1
            for group in active_groups_result:
                group_id = group['group_id']
                if not group_id:
                    continue
                masked_group_id = system_plugin.mask_id(group_id)
                info.append(f"  {idx}. {masked_group_id} ({group['msg_count']}Êù°)")
                idx += 1
        
        if active_users_result:
            info.append('üëë ÊúÄÊ¥ªË∑ÉÁî®Êà∑:')
            idx = 1
            for user in active_users_result:
                user_id = user['user_id']
                if not user_id:
                    continue
                masked_user_id = system_plugin.mask_id(user_id)
                info.append(f"  {idx}. {masked_user_id} ({user['msg_count']}Êù°)")
                idx += 1
        
        query_time = round((time.time() - start_time) * 1000)
        info.append(f'üïí Êü•ËØ¢ËÄóÊó∂: {query_time}ms')
        info.append(f'üìÅ Êï∞ÊçÆÊ∫ê: ÂÆûÊó∂Êï∞ÊçÆÂ∫ìÊü•ËØ¢')
        
        if USE_MARKDOWN:
            button_configs = [
                [
                    {'text': 'Êü•ËØ¢dau', 'data': 'dau', 'type': 2, 'enter': False},
                    {'text': '‰ªäÊó•DAU', 'data': 'dau'}
                ],
                [{'text': 'Áî®Êà∑ÁªüËÆ°', 'data': 'Áî®Êà∑ÁªüËÆ°'}]
            ]
            buttons = system_plugin.create_buttons(event, button_configs)
            event.reply('\n'.join(info), buttons, hide_avatar_and_center=True)
        else:
            event.reply('\n'.join(info))
        
        if cursor:
            cursor.close()
        if connection:
            log_db_pool.release_connection(connection)
    
    @classmethod
    def _send_dau_from_database(cls, event, dau_data, target_date, start_time):
        msg_stats = dau_data.get('message_stats', {})
        
        info = [
            f'<@{event.user_id}>',
            f'üìä {target_date.strftime("%m-%d")} Ê¥ªË∑ÉÁªüËÆ°'
        ]
        
        info.append(f'üë§ Ê¥ªË∑ÉÁî®Êà∑Êï∞: {msg_stats.get("active_users", 0)}')
        info.append(f'üë• Ê¥ªË∑ÉÁæ§ËÅäÊï∞: {msg_stats.get("active_groups", 0)}')
        info.append(f'üí¨ Ê∂àÊÅØÊÄªÊï∞: {msg_stats.get("total_messages", 0)}')
        info.append(f'üì± ÁßÅËÅäÊ∂àÊÅØ: {msg_stats.get("private_messages", 0)}')
        
        peak_hour = msg_stats.get("peak_hour", 0)
        peak_hour_count = msg_stats.get("peak_hour_count", 0)
        info.append(f'‚è∞ ÊúÄÊ¥ªË∑ÉÊó∂ÊÆµ: {peak_hour}ÁÇπ ({peak_hour_count}Êù°)')
        
        event_stats = dau_data.get('event_stats', {})
        if event_stats and any(event_stats.values()):
            info.append(f'üìà ‰∫ã‰ª∂ÁªüËÆ°:')
            group_join = event_stats.get("group_join_count", 0)
            group_leave = event_stats.get("group_leave_count", 0) 
            friend_add = event_stats.get("friend_add_count", 0)
            friend_remove = event_stats.get("friend_remove_count", 0)
            group_net = group_join - group_leave
            friend_net = friend_add - friend_remove
            info.append(f'üë• Áæ§Êï∞üî∫: {group_join} |üîª: {group_leave}')
            info.append(f'üë§ ÂèãÊï∞üî∫: {friend_add} |üîª: {friend_remove}\nüìäÁæ§ÂáÄÂ¢û: {group_net:+d} | ÂèãÂáÄÂ¢û: {friend_net:+d}')
        
        top_groups = msg_stats.get("top_groups", [])
        if top_groups:
            info.append('üîù ÊúÄÊ¥ªË∑ÉÁæ§ÁªÑ:')
            idx = 1
            for group in top_groups[:2]:
                group_id = group.get("group_id", "")
                if not group_id:
                    continue
                masked_group_id = system_plugin.mask_id(group_id)
                info.append(f"  {idx}. {masked_group_id} ({group.get('message_count', 0)}Êù°)")
                idx += 1
        
        top_users = msg_stats.get("top_users", [])
        if top_users:
            info.append('üëë ÊúÄÊ¥ªË∑ÉÁî®Êà∑:')
            idx = 1
            for user in top_users[:2]:
                user_id = user.get("user_id", "")
                if not user_id:
                    continue
                masked_user_id = system_plugin.mask_id(user_id)
                info.append(f"  {idx}. {masked_user_id} ({user.get('message_count', 0)}Êù°)")
                idx += 1
        
        query_time = round((time.time() - start_time) * 1000)
        info.append(f'üïí Êü•ËØ¢ËÄóÊó∂: {query_time}ms')
        info.append(f'üìÅ Êï∞ÊçÆÊ∫ê: Êï∞ÊçÆÂ∫ì')
        
        if dau_data.get('generated_at'):
            gen_time = datetime.datetime.fromisoformat(dau_data['generated_at'].replace('Z', '+00:00'))
            info.append(f'üïí Êï∞ÊçÆÁîüÊàêÊó∂Èó¥: {gen_time.strftime("%m-%d %H:%M")}')
        
        if USE_MARKDOWN:
            button_configs = [
                [
                    {'text': 'Êü•ËØ¢dau', 'data': 'dau', 'type': 2, 'enter': False},
                    {'text': '‰ªäÊó•DAU', 'data': 'dau'}
                ],
                [{'text': 'Áî®Êà∑ÁªüËÆ°', 'data': 'Áî®Êà∑ÁªüËÆ°'}]
            ]
            buttons = system_plugin.create_buttons(event, button_configs)
            event.reply('\n'.join(info), buttons, hide_avatar_and_center=True)
        else:
            event.reply('\n'.join(info))
    
    @classmethod
    def _get_query_params(cls):
        return [
            ("SELECT COUNT(*) as count FROM M_users", None, False),
            ("SELECT COUNT(*) as count FROM M_groups", None, False),
            ("SELECT COUNT(*) as count FROM M_members", None, False),
            ("""
                SELECT group_id, JSON_LENGTH(users) as member_count
                FROM M_groups_users
                ORDER BY member_count DESC
                LIMIT 1
            """, None, False),
            ("SELECT 1 as placeholder", None, False)
        ]
    
    @classmethod
    def _get_group_info_params(cls, group_id):
        return [
            ("SELECT users FROM M_groups_users WHERE group_id = %s", (group_id,), False),
            ("""
                SELECT group_id, JSON_LENGTH(users) as member_count
                FROM M_groups_users
                ORDER BY member_count DESC
            """, None, True)
        ]
    
    @classmethod
    def _process_result(cls, results):
        user_count = results[0]['count'] if results[0] else 0
        group_count = results[1]['count'] if results[1] else 0
        private_users_count = results[2]['count'] if results[2] else 0
        
        most_active_result = results[3]
        if most_active_result:
            group_id = most_active_result.get('group_id', "Êó†Êï∞ÊçÆ")
            if group_id != "Êó†Êï∞ÊçÆ":
                group_id = system_plugin.mask_id(group_id)
            
            most_active_group = {
                'group_id': group_id,
                'member_count': most_active_result.get('member_count', 0)
            }
        else:
            most_active_group = {'group_id': "Êó†Êï∞ÊçÆ", 'member_count': 0}
        
        return {
            'user_count': user_count,
            'group_count': group_count,
            'private_users_count': private_users_count,
            'most_active_group': most_active_group
        }
    
    @classmethod
    def _process_group_results(cls, results, group_id):
        group_members = 0
        if results[0] and results[0].get('users'):
            users = results[0]['users']
            if isinstance(users, str):
                users = json.loads(users)
            group_members = len(users)
        
        group_rank = 'N/A'
        if results[1]:
            for i, group in enumerate(results[1], 1):
                if group.get('group_id') == group_id:
                    group_rank = i
                    break
        
        return {
            'member_count': group_members,
            'rank': group_rank
        }
    
    @classmethod
    def get_stats(cls, event):
        start_time = time.time()
        db = DatabaseService()
        query_params = cls._get_query_params()
        
        group_results = None
        if event.group_id:
            group_query_params = cls._get_group_info_params(event.group_id)
            group_results = db.execute_concurrent_queries(group_query_params)
        
        results = db.execute_concurrent_queries(query_params)
        stats = cls._process_result(results)
        
        info = [
            f'<@{event.user_id}>',
            f'üìä ÁªüËÆ°‰ø°ÊÅØ',
        ]
        
        if event.group_id and group_results:
            group_info = cls._process_group_results(group_results, event.group_id)
            info.append(f'üë• ÂΩìÂâçÁæ§ÊàêÂëò: {group_info["member_count"]}')
        
        info.append(f'üë§ Â•ΩÂèãÊÄªÊï∞Èáè: {stats["private_users_count"]}')
        info.append(f'üë• Áæ§ÁªÑÊÄªÊï∞Èáè: {stats["group_count"]}')
        info.append(f'üë• ÊâÄÊúâÁî®Êà∑ÊÄªÊï∞Èáè: {stats["user_count"]}')
        info.append(f'üîù ÊúÄÂ§ßÁæ§: {stats["most_active_group"]["group_id"]} (Áæ§Âëò: {stats["most_active_group"]["member_count"]})')
        
        if event.group_id and group_results:
            group_info = cls._process_group_results(group_results, event.group_id)
            info.append(f'üìà ÂΩìÂâçÁæ§ÊéíÂêç: Á¨¨{group_info["rank"]}Âêç')
        
        query_time = round((time.time() - start_time) * 1000)
        info.append(f'üïí Êü•ËØ¢ËÄóÊó∂: {query_time}ms')
        
        if USE_MARKDOWN:
            button_configs = [[{'text': 'DAUÊü•ËØ¢', 'data': 'dau'}]]
            buttons = system_plugin.create_buttons(event, button_configs)
            event.reply('\n'.join(info), buttons, hide_avatar_and_center=True)
        else:
            event.reply('\n'.join(info))
    
    @staticmethod
    def about_info(event):
        PluginManager.load_plugins()
        kernel_count = len(PluginManager._plugins)
        function_count = len(PluginManager._regex_handlers)
        python_version = platform.python_version()
            
        msg = f'<@{event.user_id}>ÂÖ≥‰∫é‰ºäËïæÂ®ú\n___\nüîå ËøûÊé•ÊñπÂºè: WebHook\nü§ñ Êú∫Âô®‰∫∫QQ: 3889045760\nüÜî Êú∫Âô®‰∫∫appid: 102134274\nüöÄ ÂÜÖÊ†∏ÁâàÊú¨ÔºöElaina 1.2.3\nüèóÔ∏è ËøûÊé•BotÊ°ÜÊû∂: Elaina-Mbot\n‚öôÔ∏è PythonÁâàÊú¨: {python_version}\nüí´ Â∑≤Âä†ËΩΩÂÜÖÊ†∏Êï∞: {kernel_count}\n‚ö° Â∑≤Âä†ËΩΩÂ§ÑÁêÜÂô®Êï∞: {function_count}\n\n\n>Tip:Âè™ÊúâËâæÁâπ‰ºäËïæÂ®úÔºå‰ºäËïæÂ®úÊâçËÉΩÊé•Êî∂Âà∞‰Ω†ÁöÑÊ∂àÊÅØ~ÔºÅ'
        if USE_MARKDOWN:
            button_configs = [[
                {'text': 'ËèúÂçï', 'data': '/ËèúÂçï'},
                {'text': 'Â®±‰πêËèúÂçï', 'data': '/Â®±‰πêËèúÂçï'}
            ]]
            btn = system_plugin.create_buttons(event, button_configs)
            system_plugin.safe_reply(event, msg, btn)
        else:
            event.reply(msg) 
    
    @staticmethod
    def restart_bot(event):
        import psutil
        import importlib.util
        
        current_pid = os.getpid()
        current_dir = os.getcwd()
        main_py_path = os.path.join(current_dir, 'main.py')
        
        if not os.path.exists(main_py_path):
            event.reply('‚ùå main.pyÊñá‰ª∂‰∏çÂ≠òÂú®ÔºÅ')
            return
        
        config_path = os.path.join(current_dir, 'config.py')
        config = None
        if os.path.exists(config_path):
            spec = importlib.util.spec_from_file_location("config", config_path)
            config = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(config)
        
        is_dual_process = False
        main_port = 5001
        web_port = 5002
        
        if config and hasattr(config, 'SERVER_CONFIG'):
            server_config = config.SERVER_CONFIG
            is_dual_process = server_config.get('web_dual_process', False)
            main_port = server_config.get('port', 5001)
            web_port = server_config.get('web_port', 5002)
        
        restart_mode = "Áã¨Á´ãËøõÁ®ãÊ®°Âºè" if is_dual_process else "ÂçïËøõÁ®ãÊ®°Âºè"
        event.reply(f'üîÑ Ê≠£Âú®ÈáçÂêØÊú∫Âô®‰∫∫... ({restart_mode})\n‚è±Ô∏è È¢ÑËÆ°ÈáçÂêØÊó∂Èó¥: 1Áßí')
        
        restart_status = {
            'restart_time': datetime.datetime.now().isoformat(),
            'completed': False,
            'message_id': event.message_id,
            'user_id': event.user_id,
            'group_id': event.group_id if hasattr(event, 'is_group') and event.is_group else 'c2c'
        }
        
        restart_status_file = system_plugin._get_restart_status_file()
        with open(restart_status_file, 'w', encoding='utf-8') as f:
            json.dump(restart_status, f, ensure_ascii=False)
        
        restart_script_content = system_plugin._create_restart_python_script(
            main_py_path, is_dual_process, main_port, web_port, current_pid
        )
        restart_script_path = os.path.join(current_dir, 'bot_restarter.py')
        
        with open(restart_script_path, 'w', encoding='utf-8') as f:
            f.write(restart_script_content)
        
        if is_dual_process:
            main_pids = system_plugin._find_processes_by_port(main_port)
            web_pids = system_plugin._find_processes_by_port(web_port)
            logger.info(f"[ÈáçÂêØ] ‰∏ªÁ®ãÂ∫èÁ´ØÂè£: {main_port}, WebÈù¢ÊùøÁ´ØÂè£: {web_port}")
            logger.info(f"[ÈáçÂêØ] ‰∏ªÁ®ãÂ∫èËøõÁ®ã: {main_pids}, WebÈù¢ÊùøËøõÁ®ã: {web_pids}")
        
        is_windows = platform.system().lower() == 'windows'
        
        if is_windows:
            subprocess.Popen(['python', restart_script_path], cwd=current_dir,
                           creationflags=subprocess.CREATE_NEW_CONSOLE)
        else:
            subprocess.Popen([sys.executable, restart_script_path], cwd=current_dir,
                           start_new_session=True)
    
    @staticmethod
    def _find_processes_by_port(port):
        import psutil
        pids = []
        for conn in psutil.net_connections():
            if conn.laddr.port == port and conn.status == 'LISTEN':
                try:
                    proc = psutil.Process(conn.pid)
                    pids.append(conn.pid)
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
        return pids
    
    @staticmethod
    def _create_restart_python_script(main_py_path, is_dual_process=False, main_port=5001, web_port=5002, current_python_pid=None):
        if current_python_pid is None:
            current_python_pid = os.getpid()
            
        if is_dual_process:
            kill_ports_code = f"""
        ports_to_kill = [{main_port}, {web_port}]
        pids_to_kill = []
        
        for port in ports_to_kill:
            for conn in psutil.net_connections():
                if conn.laddr.port == port and conn.status == 'LISTEN':
                    try:
                        proc = psutil.Process(conn.pid)
                        pids_to_kill.append(conn.pid)
                        print(f"ÊâæÂà∞Á´ØÂè£{{port}}ÁöÑËøõÁ®ã: PID {{conn.pid}}")
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        continue
        
        pids_to_kill = list(set(pids_to_kill))
        
        for pid in pids_to_kill:
            try:
                if platform.system().lower() == 'windows':
                    result = subprocess.run(['taskkill', '/PID', str(pid), '/F'], 
                                         check=False, capture_output=True)
                    print(f"Windows: ÊùÄÊ≠ªËøõÁ®ã PID {{pid}}, ËøîÂõûÁ†Å: {{result.returncode}}")
                else:
                    proc = psutil.Process(pid)
                    proc.terminate()
                    try:
                        proc.wait(timeout=3)
                        print(f"Linux: ËøõÁ®ã PID {{pid}} Â∑≤Ê≠£Â∏∏ÁªàÊ≠¢")
                    except psutil.TimeoutExpired:
                        proc.kill()
                        print(f"Linux: Âº∫Âà∂ÊùÄÊ≠ªËøõÁ®ã PID {{pid}}")
            except Exception as e:
                print(f"ÊùÄÊ≠ªËøõÁ®ã{{pid}}Â§±Ë¥•: {{e}}")
        
        # Âø´ÈÄüÈ™åËØÅËøõÁ®ãÁªàÊ≠¢
        time.sleep(0.3)
        
        # Âø´ÈÄüÈ™åËØÅÂÖ≥ÈîÆËøõÁ®ãÊòØÂê¶Â∑≤ÁªàÊ≠¢
        for pid in pids_to_kill[:2]:  # Âè™Ê£ÄÊü•Ââç2‰∏™ËøõÁ®ã
            try:
                proc = psutil.Process(pid)
                if proc.is_running():
                    print(f"Âø´ÈÄüÂº∫ÊùÄËøõÁ®ã: PID {{pid}}")
                    if platform.system().lower() == 'windows':
                        subprocess.run(['taskkill', '/PID', str(pid), '/F', '/T'], check=False, timeout=1)
                    else:
                        proc.kill()
            except (psutil.NoSuchProcess, subprocess.TimeoutExpired):
                pass
            except Exception:
                pass
                """
        else:
            kill_ports_code = f"""
        target_pid = {current_python_pid}
        try:
            proc = psutil.Process(target_pid)
            print(f"ÂáÜÂ§áÊùÄÊ≠ªPythonËøõÁ®ã: PID {{target_pid}}")
            
            if platform.system().lower() == 'windows':
                subprocess.run(['taskkill', '/PID', str(target_pid), '/F', '/T'], 
                             check=False, capture_output=True, timeout=2)
                print(f"Windows: Â∑≤ÊùÄÊ≠ªËøõÁ®ã PID {{target_pid}}")
            else:
                proc.terminate()
                try:
                    proc.wait(timeout=1)
                    print(f"Linux: ËøõÁ®ã PID {{target_pid}} Â∑≤Ê≠£Â∏∏ÁªàÊ≠¢")
                except psutil.TimeoutExpired:
                    proc.kill()
                    print(f"Linux: Âº∫Âà∂ÊùÄÊ≠ªËøõÁ®ã PID {{target_pid}}")
        except psutil.NoSuchProcess:
            print(f"ËøõÁ®ã {{target_pid}} ‰∏çÂ≠òÂú®ÊàñÂ∑≤ÁªàÊ≠¢")
        except Exception as e:
            print(f"ÊùÄÊ≠ªËøõÁ®ã{{target_pid}}Â§±Ë¥•: {{e}}")
        
        time.sleep(0.2)
                """
        
        script_content = f'''#!/usr/bin/env python3

import os
import sys
import time
import signal
import platform
import subprocess
import psutil

def main():
    main_py_path = r"{main_py_path}"
    
    try:{kill_ports_code}
    except Exception as e:
        print(f"ÊùÄÊ≠ªËøõÁ®ãËøáÁ®ã‰∏≠Âá∫Èîô: {{e}}")
    
    time.sleep(0.1)
    
    ports_to_check = [{main_port}, {web_port}] if {str(is_dual_process)} else [5001]
    max_wait = 2
    wait_count = 0
    while wait_count < max_wait:
        ports_still_occupied = False
        try:
            for conn in psutil.net_connections():
                if conn.laddr.port in ports_to_check and conn.status == 'LISTEN':
                    ports_still_occupied = True
                    break
        except:
            pass
            
        if not ports_still_occupied:
            print("Á´ØÂè£Â∑≤ÈáäÊîæ")
            break
        else:
            time.sleep(0.2)
            wait_count += 0.2
    
    try:
        os.chdir(os.path.dirname(main_py_path))
        
        print(f"Ê≠£Âú®ÈáçÊñ∞ÂêØÂä®‰∏ªÁ®ãÂ∫è: {{main_py_path}}")
        
        if platform.system().lower() == 'windows':
            subprocess.Popen(
                [sys.executable, main_py_path],
                creationflags=subprocess.CREATE_NEW_CONSOLE,
                cwd=os.path.dirname(main_py_path)
            )
        else:
            try:
                script_path = __file__
                if os.path.exists(script_path):
                    os.remove(script_path)
            except:
                pass
            os.execv(sys.executable, [sys.executable, main_py_path])
        
        print("ÈáçÂêØÂëΩ‰ª§Â∑≤ÊâßË°å")
        
    except Exception as e:
        print(f"ÈáçÂêØÂ§±Ë¥•: {{e}}")
        sys.exit(1)
    
    if platform.system().lower() == 'windows':
        time.sleep(1)
        try:
            script_path = __file__
            if os.path.exists(script_path):
                os.remove(script_path)
        except:
            pass
        sys.exit(0)

if __name__ == "__main__":
    main()
'''
        return script_content
    
    @staticmethod
    def fill_user_names(event):
        start_time = time.time()
        db = Database()
        users_table = db.get_table_name('users')
        
        query = f"SELECT user_id FROM {users_table} WHERE name IS NULL OR name = ''"
        result = DatabaseService.execute_query(query, None, fetch_all=True)
        
        if not result or not isinstance(result, list):
            event.reply(f"<@{event.user_id}>\n‚úÖ ÊâÄÊúâÁî®Êà∑ÈÉΩÂ∑≤ÊúâÊòµÁß∞ÔºåÊó†ÈúÄË°•ÂÖ®ÔºÅ")
            return
        
        total_users = len(result)
        event.reply(f"<@{event.user_id}>\nüîÑ ÂºÄÂßãË°•ÂÖ®ÊòµÁß∞...\nüìä ÈúÄË¶ÅÂ§ÑÁêÜ: {total_users} ‰∏™Áî®Êà∑")
        
        success_count = 0
        failed_count = 0
        
        for i, user_row in enumerate(result, 1):
            user_id = user_row.get('user_id')
            if not user_id:
                continue
            
            name = db.fetch_user_name_from_api(user_id)
            
            if name:
                sql = f"UPDATE {users_table} SET name = %s WHERE user_id = %s"
                DatabaseService.execute_update(sql, (name, user_id))
                success_count += 1
            else:
                failed_count += 1
            
            if i % 200000 == 0:
                progress = (i / total_users) * 100
                event.reply(f"‚è≥ Â§ÑÁêÜËøõÂ∫¶: {i}/{total_users} ({progress:.1f}%)\n‚úÖ ÊàêÂäü: {success_count} | ‚ùå Â§±Ë¥•: {failed_count}")
        
        total_time = round((time.time() - start_time) * 1000)
        info = [
            f'<@{event.user_id}>',
            f'‚úÖ ÊòµÁß∞Ë°•ÂÖ®ÂÆåÊàêÔºÅ',
            f'üë§ Â§ÑÁêÜÊÄªÊï∞: {total_users} ‰∏™',
            f'‚úÖ ÊàêÂäüË°•ÂÖ®: {success_count} ‰∏™',
            f'‚ùå Ëé∑ÂèñÂ§±Ë¥•: {failed_count} ‰∏™',
            f'üïí ÊÄªËÄóÊó∂: {total_time}ms'
        ]
        
        if USE_MARKDOWN:
            button_configs = [[
                {'text': 'Áî®Êà∑ÁªüËÆ°', 'data': 'Áî®Êà∑ÁªüËÆ°'},
                {'text': 'DAUÊü•ËØ¢', 'data': 'dau'}
            ]]
            buttons = system_plugin.create_buttons(event, button_configs)
            event.reply('\n'.join(info), buttons, hide_avatar_and_center=True)
        else:
            event.reply('\n'.join(info))
    
    @staticmethod
    def query_bot_info(qq_number):
        if qq_number.startswith('1'):
            api_url = f"https://i.elaina.vin/api/bot/xx.php?appid={qq_number}"
        else:
            api_url = BOT_API_URL.format(qq_number)
        try:
            return get_json(api_url, timeout=10)
        except Exception:
            return {"ÈîôËØØ": "Êü•ËØ¢Â§±Ë¥•"}
    
    @staticmethod
    def format_bot_info(bot_info):
        if "ÈîôËØØ" in bot_info:
            return "ËØ•Ë¥¶Âè∑‰∏çÊòØBOTË¥¶Âè∑" if bot_info["ÈîôËØØ"] == "Êï∞ÊçÆÊ†ºÂºè‰∏çÊ≠£Á°Æ" else "Êü•ËØ¢Â§±Ë¥•"
        
        info = []
        
        if "QQÂè∑" in bot_info:
            info.append(f"UIN: {bot_info['QQÂè∑']}")
        if "‰ªãÁªç" in bot_info:
            intro = bot_info['‰ªãÁªç'].strip()
            if intro and len(intro) > 100:
                intro = intro[:100] + "..."
            if intro:
                info.append(f"‰ªãÁªç: {intro}")
        if "È™åËØÅ‰ø°ÊÅØ" in bot_info:
            info.append(f"È™åËØÅ‰ø°ÊÅØ: {bot_info['È™åËØÅ‰ø°ÊÅØ']}")
        if "APPID" in bot_info:
            info.append(f"APPID: {bot_info['APPID']}")
        if "ÂºÄÂèëËÄÖ" in bot_info:
            info.append(f"ÂºÄÂèëËÄÖ: {bot_info['ÂºÄÂèëËÄÖ']}")
        if "Áä∂ÊÄÅ" in bot_info:
            info.append(f"Áä∂ÊÄÅ: {bot_info['Áä∂ÊÄÅ']}")
        if "ËøêË°åÁä∂ÊÄÅ" in bot_info:
            info.append(f"ËøêË°åÁä∂ÊÄÅ: {bot_info['ËøêË°åÁä∂ÊÄÅ']}")
        if "ÊòØÂê¶ÂèØÈÇÄËØ∑" in bot_info:
            info.append(f"ÊòØÂê¶ÂèØÈÇÄËØ∑: {bot_info['ÊòØÂê¶ÂèØÈÇÄËØ∑']}")
        if "ÊòØÂê¶‰∏ãÁ∫ø" in bot_info:
            info.append(f"ÊòØÂê¶‰∏ãÁ∫ø: {bot_info['ÊòØÂê¶‰∏ãÁ∫ø']}")
        if "ÊòØÂê¶ÂÜÖÊµã" in bot_info:
            info.append(f"ÊòØÂê¶ÂÜÖÊµã: {bot_info['ÊòØÂê¶ÂÜÖÊµã']}")
        if "ÊòØÂê¶Êô∫ËÉΩ‰ΩìËØ≠Èü≥" in bot_info:
            info.append(f"ÊòØÂê¶Êô∫ËÉΩ‰ΩìËØ≠Èü≥: {bot_info['ÊòØÂê¶Êô∫ËÉΩ‰ΩìËØ≠Èü≥']}")
        if "ÊòØÂê¶Â∞ÅÁ¶Å" in bot_info:
            info.append(f"ÊòØÂê¶Â∞ÅÁ¶Å: {bot_info['ÊòØÂê¶Â∞ÅÁ¶Å']}")
        if "ÊòØÂê¶ÂèØÂàÜ‰∫´" in bot_info:
            info.append(f"ÊòØÂê¶ÂèØÂàÜ‰∫´: {bot_info['ÊòØÂê¶ÂèØÂàÜ‰∫´']}")
        if "Á±ªÂûã" in bot_info:
            info.append(f"Á±ªÂûã: {bot_info['Á±ªÂûã']}")
        if "Á¶ÅË®ÄÁä∂ÊÄÅ" in bot_info:
            info.append(f"Á¶ÅË®ÄÁä∂ÊÄÅ: {bot_info['Á¶ÅË®ÄÁä∂ÊÄÅ']}")
        if "Â§ÑÁΩöÁä∂ÊÄÅ" in bot_info:
            info.append(f"Â§ÑÁΩöÁä∂ÊÄÅ: {bot_info['Â§ÑÁΩöÁä∂ÊÄÅ']}")
        if "ÂÆòÊñπÈ¢ëÈÅìID" in bot_info:
            info.append(f"ÂÆòÊñπÈ¢ëÈÅìID: {bot_info['ÂÆòÊñπÈ¢ëÈÅìID']}")
        
        if "Êåá‰ª§ÂàóË°®" in bot_info and bot_info["Êåá‰ª§ÂàóË°®"]:
            cmds = []
            for i, cmd in enumerate(bot_info["Êåá‰ª§ÂàóË°®"], 1):
                if i > 3:
                    break
                if isinstance(cmd, dict) and "Êåá‰ª§" in cmd:
                    cmds.append(cmd['Êåá‰ª§'])
            if cmds:
                info.append(f"Êåá‰ª§Á§∫‰æã: {', '.join(cmds)}")
        
        # ‰ΩøÁî®ÂºïÁî®Ê†ºÂºè
        quoted_info = '\n'.join([f"> {line}" for line in info])
        return f"\n{quoted_info}\n"
    
    @staticmethod
    def send_bot_confirmation_request(event):
        warning_message = "‚ö†Ô∏è Ë≠¶ÂëäÔºöËØ•ÂäüËÉΩÁî®‰∫éÂºÄÂèëËÄÖÊü•ËØ¢Ëá™Â∑±ÁöÑÊú∫Âô®‰∫∫‰ΩøÁî®Ôºå‰Ω†ÂèëÂá∫ÁöÑÊú∫Âô®‰∫∫Ë¥¶Âè∑Êï∞ÊçÆ‰∏çÂÅö‰ªª‰Ωï‰øùÁïôÔºåÂ¶ÇÊûúÂá∫Áé∞ÊÅ∂ÊÑèÊü•ËØ¢ÔºåÂàôÂØπËøùËßÑËÄÖËøõË°åÂ∞ÅÁ¶Å„ÄÇ\n\nËØ∑Á°ÆËÆ§‰Ω†‰ªÖ‰ºöÊü•ËØ¢Ëá™Â∑±ÁöÑÊú∫Âô®‰∫∫ÔºåÂèëÈÄÅ‰ª•‰∏ãÂÜÖÂÆπÁ°ÆËÆ§Ôºö"
        confirmation_text = "ÊàëÁ°ÆËÆ§Êåá‰ª§'Êü•ËØ¢Êú∫Âô®‰∫∫'ÂäüËÉΩ ‰ªÖÊü•ËØ¢Ëá™Â∑±ÁöÑÊú∫Âô®‰∫∫ÔºåÂ¶ÇÊúâËøùÂèçÔºåÂêéÊûúÁî±Ëá™Â∑±ÊâøÊãÖ„ÄÇ"
        
        if USE_MARKDOWN:
            buttons = event.button([
                event.rows([
                    {'text': 'ÁÇπÂáªÁ°ÆËÆ§', 'data': confirmation_text, 'type': 2, 'style': 4}
                ])
            ])
            event.reply(f"{warning_message}\n\n{confirmation_text}", buttons)
        else:
            event.reply(f"{warning_message}\n\n{confirmation_text}")
    
    @staticmethod
    def handle_bot_query(event):
        content = event.content.strip()
        match = re.match(r"^Êü•ËØ¢Êú∫Âô®‰∫∫\s*(\d{1,})$", content)
        if not match:
            return
            
        qq_number = match.group(1)
        
        if not (8 <= len(qq_number) <= 10):
            event.reply("ËØ∑ËæìÂÖ•8-10‰ΩçQQÂè∑ËøõË°åÊü•ËØ¢")
            return
        
        user_id = str(event.user_id)
        if user_id not in confirmed_users:
            system_plugin.send_bot_confirmation_request(event)
            return
        
        record_query(user_id, qq_number)
        bot_info = system_plugin.query_bot_info(qq_number)
        
        response_content = ""
        
        # Â§¥ÂÉèÂíåÂêçÂ≠óÂú®Âêå‰∏ÄË°å
        if "Â§¥ÂÉè" in bot_info and bot_info["Â§¥ÂÉè"]:
            bot_name = bot_info.get("ÂêçÂ≠ó", "Êú∫Âô®‰∫∫")
            response_content += f"![Êú∫Âô®‰∫∫ #50px #50px]({bot_info['Â§¥ÂÉè']}) **{bot_name}**\n\n"
        
        response_content += system_plugin.format_bot_info(bot_info)
        response_content += "\n\n>‰Ω†Â∑≤Á°ÆËÆ§‰ΩøÁî®Êù°Ê¨æÔºå‰Ω†Â∞Ü‰øùËØÅ‰Ω†ÊòØËØ•Êú∫Âô®‰∫∫ÂºÄÂèëËÄÖÔºåÂ¶ÇÊúâËøùÂèçÔºåÂ∞ÜÂØπËøùËßÑËÄÖËøõË°åÂ∞ÅÁ¶Å„ÄÇ"
        
        if USE_MARKDOWN:
            button_rows = []
            
            bot_name = bot_info.get("ÂêçÂ≠ó", "Êú∫Âô®‰∫∫")
            if "Êú∫Âô®‰∫∫ÈìæÊé•" in bot_info and bot_info["Êú∫Âô®‰∫∫ÈìæÊé•"]:
                button_rows.append([{'text': bot_name, 'link': bot_info["Êú∫Âô®‰∫∫ÈìæÊé•"], 'style': 1}])
            
            if "È¢ÑËßàÂõæÁâá" in bot_info and bot_info["È¢ÑËßàÂõæÁâá"]:
                preview_buttons = []
                for i, img in enumerate(bot_info["È¢ÑËßàÂõæÁâá"][:3], 1):
                    if isinstance(img, dict) and "ÂõæÁâáÂú∞ÂùÄ" in img:
                        desc = img.get("ÂõæÁâáÊèèËø∞", f"È¢ÑËßà{i}")
                        img_url = img["ÂõæÁâáÂú∞ÂùÄ"]
                        if '?' in img_url:
                            img_url += '&imageMogr2/format/jpg'
                        else:
                            img_url += '?imageMogr2/format/jpg'
                        preview_buttons.append({'text': desc, 'data': img_url, 'type': 0, 'style': 1})
                if preview_buttons:
                    button_rows.append(preview_buttons)
            
            if "ÂèçÈ¶àÈ°µÈù¢ÈìæÊé•" in bot_info and bot_info["ÂèçÈ¶àÈ°µÈù¢ÈìæÊé•"]:
                button_rows.append([{'text': 'ÂèçÈ¶àÈ°µÈù¢', 'link': bot_info["ÂèçÈ¶àÈ°µÈù¢ÈìæÊé•"], 'style': 1}])
            
            buttons = event.button([event.rows(row) for row in button_rows]) if button_rows else None
            event.reply(response_content, buttons, hide_avatar_and_center=True, auto_delete_time=75)
        else:
            event.reply(response_content, auto_delete_time=75)
    
    @staticmethod
    def handle_bot_confirm(event):
        user_id = str(event.user_id)
        
        if user_id in confirmed_users:
            event.reply("‰Ω†Â∑≤ÁªèÁ°ÆËÆ§Ëøá‰ΩøÁî®Êù°Ê¨æÔºåÂèØ‰ª•Áõ¥Êé•‰ΩøÁî®Êü•ËØ¢ÂäüËÉΩ„ÄÇ")
            return
        
        confirmed_users.add(user_id)
        save_confirmed_users()
        
        if USE_MARKDOWN:
            buttons = event.button([
                event.rows([
                    {'text': 'Êü•ËØ¢Êú∫Âô®‰∫∫', 'data': 'Êü•ËØ¢Êú∫Âô®‰∫∫', 'type': 2, 'enter': False, 'style': 1}
                ])
            ])
            event.reply("Á°ÆËÆ§ÊàêÂäüÔºå‰Ω†Áé∞Âú®ÂèØ‰ª•‰ΩøÁî®Êü•ËØ¢Êú∫Âô®‰∫∫ÂäüËÉΩ‰∫Ü„ÄÇ", buttons)
        else:
            event.reply("Á°ÆËÆ§ÊàêÂäüÔºå‰Ω†Áé∞Âú®ÂèØ‰ª•‰ΩøÁî®Êü•ËØ¢Êú∫Âô®‰∫∫ÂäüËÉΩ‰∫Ü„ÄÇ")
    
    @staticmethod
    def add_blacklist(event):
        reason = event.matches[0] if event.matches[0] else "Êú™ÊåáÊòéÂéüÂõ†"
        user_id = event.matches[1] if len(event.matches) > 1 and event.matches[1] else None
        if not user_id:
            return event.reply("ËØ∑Êèê‰æõÁî®Êà∑ID")
        if user_id in OWNER_IDS:
            return event.reply("Êó†Ê≥ïÂ∞Ü‰∏ª‰∫∫Ê∑ªÂä†Âà∞ÈªëÂêçÂçï")
        blacklist[user_id] = reason
        save_blacklist()
        
        message = f"Â∑≤Ê∑ªÂä†Áî®Êà∑ {user_id} Âà∞ÈªëÂêçÂçï\nÂéüÂõ†: {reason}"
        
        if USE_MARKDOWN:
            button_configs = [[
                {'text': 'ÁªßÁª≠Ê∑ªÂä†', 'data': f'ÈªëÂêçÂçïÊ∑ªÂä† {reason} ', 'type': 2, 'enter': False, 'style': 1},
                {'text': 'Êü•ÁúãÈªëÂêçÂçï', 'data': 'ÈªëÂêçÂçïÊü•Áúã', 'type': 2, 'style': 1}
            ]]
            buttons = system_plugin.create_buttons(event, button_configs)
            event.reply(message, buttons)
        else:
            event.reply(message)
    
    @staticmethod
    def remove_blacklist(event):
        user_id = event.matches[0]
        if user_id not in blacklist:
            return event.reply(f"Áî®Êà∑ {user_id} ‰∏çÂú®ÈªëÂêçÂçï‰∏≠")
        reason = blacklist.pop(user_id, "Êú™Áü•")
        save_blacklist()
        event.reply(f"Â∑≤ÁßªÈô§Áî®Êà∑ {user_id}\nÂéüÂõ†: {reason}")
    
    @staticmethod
    def view_blacklist(event):
        if not blacklist:
            return event.reply("ÈªëÂêçÂçï‰∏∫Á©∫")
        reply = "ÈªëÂêçÂçïÂàóË°®Ôºö\n" + "\n".join([f"{uid}: {reason}" for uid, reason in blacklist.items()])
        event.reply(reply)
    
    @staticmethod
    def show_blacklist_help(event):
        event.reply("ÈªëÂêçÂçïÊåá‰ª§Ôºö\nÈªëÂêçÂçïÊ∑ªÂä† [ÂéüÂõ†] [Áî®Êà∑ID] - Ê∑ªÂä†Áî®Êà∑\nÈªëÂêçÂçïÂà†Èô§ [Áî®Êà∑ID] - Âà†Èô§Áî®Êà∑\nÈªëÂêçÂçïÊü•Áúã - Êü•ÁúãÂàóË°®\nÈªëÂêçÂçïÂ∏ÆÂä© - ÊòæÁ§∫Â∏ÆÂä©")
 